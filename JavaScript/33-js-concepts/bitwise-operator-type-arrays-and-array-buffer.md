#  Bitwise Operator, Type Arrays and Array Buffer

### Bitwise Operator

비트(bit) : 기술적으로 컴퓨터는 숫자나 문자, 문자열로 작동하는것이 아니라 이진 숫자(비트)만 사용한다. 그리고 UTF-8과 같은 인코딩을 사용해 저장된 비트 조합을 숫자, 문자, 다른 기호에 매핑한다.

자바스크립트에서 9,007,199,254,740,991까지의 범위(64비트의 환경)를 가진 모든 정수들은  `toString(2)` 메소드를 통해 이진 문자열로 표현 될 수 있다.

```javascript
(2).toString(2); // "10"

(4).toString(2); // "100"

(9).toString(2); // "1001"

(39812).toString(2); // "1001101110000100"
```

비트 연산자를 이용하면 이진 문자열을 직접 비교/조작 할 수 있다.

실제로 비트 연산자는 드물게 사용되지만 몇몇 경우에서 비트 연산자를 활용하면 효과적으로 코드를 작성 할 수 있다.

<br>

#### `&` :  Bitwise AND

비교 대상인 두 비트가 모두 1이면 1을 반환한다. 다른 모든 경우에는 0을 반환한다.

```javascript
12 & 15 // 12

// 12는 이진수로 1100, 15는 1111 이므로
// 1100와 1111의 AND 연산의 결과는 1100, 따라서 12 반환
```

<br>

#### `|` : Bitwise OR

비교 대상인 두 비트 중 적어도 1이 하나라도 있는 경우 1을 반환한다. 두 비트 모두 0 인 경우 0을 반환한다.

```javascript
12 | 15 // 15

// 1100의 1111의 OR 연산 결과는 1111, 따라서 15 반환
```

<br>

#### `~` : Bitwise NOT

단항 연산자이며, 피 연산자의 모든 비트를 1에서 0 또는 그 반대로 반전하는 연산자이다.

피연산자를 2의 보수형식으로 부호가 있는 32비트 정수로 변환한다. 따라서 연산 후 반환되는 정수는 2의 보수의 형태이다. 가장 왼쪽 비트는 0(양의 정수) 또는 1(음의 정수) 값을 가지는 부호 비트(sign bit)이며 나머지 31비트는 정수를 나타내는데 사용된다.

```javascript
~170 // -171

// 170을 32비트 이진수로 나타내면
// 00000000000000000000000010101010
// NOT 연산 후
// 11111111111111111111111101010101
// -171 반환

// ~170 = -(170 + 1);
```


<br>

#### `^` : Bitwise XOR

비교 대상인 두 비트가 같을 경우 0을 반환하고 다를 경우 1을 반환한다.

```javascript
12 & 15 // 3

// 1100의 1111의 XOR 연산 결과는 0011, 따라서 3 반환
```

<br>

#### `<<` : Left Shift

두 개의 피연산자를 사용하며 첫번째 피연산자는 정수, 두번째 피연산자는 왼쪽으로 시프트 시킬 비트의 수이다.

0비트는 오른쪽에서부터 시프트된다. 왼쪽으로 초과된 비트는 버린다.

```javascript
170 << 3 // 1360

// 170을 이진수로 나타내면 
// 00000000000000000000000010101010
// 3비트 만큼 left shift 시키면 
// (***)00000000000000000000010101010(000), ***은 초과되어서 버리는 비트
// 00000000000000000000010101010000, 1360 반환
```

<br>

#### `>>` : Sign-propagating Right Shift

두 개의 피연사자를 사용하며 첫번째 피연산자는 정수, 두번째 피연산자는 오른쪽으로 시프트 시킬 비트의 수이다.

시프트되어서 오른쪽으로 초과된 비트는 버리며, 부호 비트의 복사본은 왼쪽에서부터 시프트 된다. 정수의 부호는 변하지 않는 이유로 Sign-propagating(부호 유지) right shift 라는 이름이 붙게 되었다.

```javascript
170 >> 3 // 21

// 170을 이진수로 나타내면 
// 00000000000000000000000010101010
// 3 비트 만큼 sign-propagating right shift 시키면
// (000)00000000000000000000000010101(***)
// 00000000000000000000000000010101, 21 반환
```

```javascript
-170 >> 3 // -22

// (111)11111111111111111111111101010(***)
// 11111111111111111111111111101010, 22 반환 
```

<br>

#### `>>>` : Zero-Fill Right Shift

`>>` 연산자와 유사하게 작동하며 왼쪽에서부터 시프트되는 비트에서 중요한 차이가 있다. `>>` 연산자는 왼쪽에서부터 부호 비트를 복사해 시프트 시키지만 `>>>` 연산자는 0 비트를 추가해 시프트 시킨다.

따라서, 양의 정수에서는 `>>` 연산자와 같은 값을 가지지만 음의 정수에서는 `>>` 연산자와 다른 값을 가지게 된다.

```javascript
170 >>> 3 // 21

// (000)00000000000000000000000010101(***)
// 00000000000000000000000000010101, 21 반환
```

```javascript
-170 >>> 3 // 536870890

// (000)11111111111111111111111101010(***)
// 00011111111111111111111111101010, 536870890 반환
```

<br>

<br>


------

**Reference**

- [Interesting use cases for JavaScript bitwise operators](https://blog.logrocket.com/interesting-use-cases-for-javascript-bitwise-operators/)
- [Programming with JS: Bitwise Operations](https://hackernoon.com/programming-with-js-bitwise-operations-393eb0745dc4)
