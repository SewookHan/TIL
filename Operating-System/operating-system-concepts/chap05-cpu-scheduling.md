# CPU Scheduling

## Basic Concepts

CPU 스케줄링이란 여러개의 프로세스가 메모리에 로드되어 있을 때 CPU가 어느 프로세스를 할당할 지를 결정하는 것이다. 멀티프로그래밍 기반의 운영체제에서 필수적인 요소이다.

스케줄링 시스템을 통해 다른 프로세스가 입출력을 기다리는 동안 CPU를 사용할 수 있게해 CPU 효율을 최대화한다.

### CPU I/O Burst Cycle

프로세스는 다음과 같은 두 사이클을 반복하며 실행된다.

- CPU 버스트: 실제 CPU를 사용하는 시간, 점유 시간
- I/O 버스트: 시스템에서 데이터 전송을 기다리는 시간

### CPU Scheduler

- ready 상태의 프로세스 중 CPU에 할당할 프로세스를 선택해야한다.
- 대기상태 중인 프로세스들은 ready qeuue에 위치해 있다.

### Preemptive vs Non-preemptive Scheduling

CPU 스케줄링은 다음과 같은 조건에서 발생한다.

- running 상태에서 waiting 상태에서 전환될 때(1)
- running 상태에서 ready 상태로 전환될 때(2)
- waiting 상태에서 ready 상태로 전활될 때(3)
- 프로세스가 terminate 될 때(4)

선점형 스케줄링이란 CPU를 선점하고 있는 프로세스에서 다른 프로세스로 전환할 수 있는 스케줄링이며 비선점형 스케줄링이란 프로세스가 CPU를 선점하고 있으면 프로세스가 릴리즈 될 때까지 다른 프로세스를 사용할 수 없는 스케줄링이다.

(2), (3)의 경우 선점형 또는 비선점형을 선택해 수행해야한다.

### Dispatcher

디스패처란 CPU 코어에 제어권을 넘겨주는 모듈이다.

- 컨텍스트 전환
- 사용자 모드로 전환
- 새로 로드된 프로그램에서 적절한 위치로 이동

하는 역할을 한다.

<br>

## Scheduling Criteria

스케줄링의 목표는 다음과 같다.

- CPU 사용률 최대화
- 처리량 향상
- 반환 시간 최소화: 실행에서 종료까지의 시간을 최소화한다.
- 대기 시간 최소화: 프로세스가 ready queue에서 대기하고 있는 시간을 최소화해 시스템 효율을 높인다.
- 응답 시간 최소화

<br>

## Scheduling Algorithm

### FCFS: First Come First Serve

- 가장 먼저 CPU 할당을 요청한 프로세스가 먼저 점유한다.
- 가장 간단한 CPU 스케줄링 알고리즘이다.
- FIFO 구조의 queue를 통해 쉽게 구현할 수 있다.
- 비선점형이다.

```
process - burst time
P1 - 24
P2 - 3
P3 - 3

1. P1 -> P2 -> P3 순서로 CPU를 점유할 경우
  - 평균 대기시간: (0 + 24 + 27) / 3 = 17

2. P2 -> P3 -> P1 순서로 CPU를 점유할 경우
  - 평균 대기시간: (0 + 3 + 6) / 3 = 3
```

- 호송 효과(convoy effect): CPU 사용시간이 많은 프로세스가 가장 먼저 점유하고 사용시간이 아주 작은 프로세스들이 이어서 점유할 경우 대기 시간 측면에서 손해가 크다.

### SJF: Shortest Job First

- 프로세스들의 CPU 버스트를 고려해 프로세스를 할당한다.
- CPU가 사용가능한 상태일 떄 CPU 버스트가 가장 작은 프로세스를 할당한다.
- 선점형, 비선점형 둘 다 가능하다.

```
process - burst time
P1 - 6
P2 - 8
P3 - 7
P4 - 3

1. P4 -> P1 -> P3 -> P2 순서로 CPU를 점유할 경우
  - 평균 대기시간: (0 + 3 + 9 + 16) / 4 = 7

2. FCFS로 CPU를 점유할 경우
  - 평균 대기시간: (0 + 6 + 14 + 21) / 4 = 10.25
```

- FCFS에 비해 평균 대기 시간이 줄어들지만, 다음 프로세스의 CPU 버스트를 예측하는 것은 사실상 불가능에 가깝다.
